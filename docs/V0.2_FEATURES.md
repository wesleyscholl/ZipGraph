# ZipGraph v0.2 Features Quick Reference

## PageRank

Calculate node importance using the PageRank algorithm:

```rust
use zipgraph_core::{Graph, centrality::pagerank};

let mut graph = Graph::new_directed();
// Add nodes and edges...

// Compute PageRank with default parameters
let ranks = pagerank(&graph, 0.85, 100, 1e-6)?;

// Access individual node scores
for (node_id, rank) in ranks.iter() {
    println!("Node {}: rank = {:.6}", node_id, rank);
}
```

**Parameters:**
- `damping_factor`: Usually 0.85 (probability of following links)
- `max_iterations`: Maximum number of iterations (typically 100)
- `tolerance`: Convergence threshold (e.g., 1e-6)

## Centrality Measures

### Degree Centrality
Measures how many connections a node has:

```rust
use zipgraph_core::centrality::degree_centrality;

let centrality = degree_centrality(&graph)?;
// Returns normalized scores (0.0 to 1.0)
```

### Closeness Centrality
Measures how close a node is to all other nodes:

```rust
use zipgraph_core::centrality::closeness_centrality;

let centrality = closeness_centrality(&graph)?;
// Higher scores mean more central position
```

### Betweenness Centrality
Identifies bridge nodes (high traffic):

```rust
use zipgraph_core::centrality::betweenness_centrality;

let centrality = betweenness_centrality(&graph)?;
// Nodes with high scores are important connectors
```

## Parallel Algorithms

### Multi-Source BFS
Run BFS from multiple sources in parallel:

```rust
use zipgraph_core::parallel::parallel_multi_source_bfs;

let sources = vec![0, 1, 2];
let target = 10;

if let Some((source, path)) = parallel_multi_source_bfs(&graph, &sources, target)? {
    println!("Shortest path from node {} to {}: {:?}", source, target, path);
}
```

### Parallel Shortest Paths
Find shortest paths from one source to multiple targets:

```rust
use zipgraph_core::parallel::parallel_shortest_paths;

let source = 0;
let targets = vec![5, 10, 15, 20];

let paths = parallel_shortest_paths(&graph, source, &targets)?;
for (target, path) in paths.iter() {
    println!("Path to {}: {:?}", target, path);
}
```

### Parallel Node Degrees
Compute degrees for all nodes in parallel:

```rust
use zipgraph_core::parallel::parallel_node_degrees;

let degrees = parallel_node_degrees(&graph)?;
```

### Parallel PageRank
PageRank computation using parallel iterators:

```rust
use zipgraph_core::parallel::parallel_pagerank;

let ranks = parallel_pagerank(&graph, 0.85, 100, 1e-6)?;
```

### K-Hop Neighbors
Find all neighbors within k hops in parallel:

```rust
use zipgraph_core::parallel::parallel_k_hop_neighbors;

let node = 5;
let k = 2; // 2 hops away

let neighbors = parallel_k_hop_neighbors(&graph, node, k)?;
println!("Nodes within {} hops of {}: {:?}", k, node, neighbors);
```

## Enhanced Node2Vec

### Basic Usage
Train node embeddings with random walks:

```rust
use zipgraph_ml::embeddings::Node2VecTrainer;

let trainer = Node2VecTrainer::new(
    10,  // walk_length
    20,  // num_walks per node
    128  // embedding dimension
);

let embeddings = trainer.train(&graph)?;
```

### Custom Parameters
Use biased random walks (p, q parameters):

```rust
let trainer = Node2VecTrainer::new(10, 20, 128)
    .with_params(
        2.0,  // p: return parameter (higher = less likely to revisit nodes)
        0.5   // q: in-out parameter (higher = more outward exploration)
    );

let embeddings = trainer.train(&graph)?;
```

### Generate Random Walks
Generate walks without training:

```rust
let walks = trainer.generate_walks(&graph);
for walk in walks.iter().take(5) {
    println!("Walk: {:?}", walk);
}
```

### Working with Embeddings
```rust
// Get embedding for a specific node
let node_embedding = embeddings.get_embedding(node_id)?;

// Compute similarity between nodes
let similarity = embeddings.cosine_similarity(node_a, node_b)?;
println!("Similarity: {:.4}", similarity);

// Find most similar nodes
let top_k = embeddings.most_similar(node_id, 10)?;
for (similar_node, score) in top_k {
    println!("Node {}: similarity = {:.4}", similar_node, score);
}
```

## Performance Tips

### When to Use Parallel Algorithms
- **Graph size**: Use parallel for graphs with >1,000 nodes
- **Multi-core**: Parallel algorithms scale with CPU cores
- **Batch operations**: Parallel shortest paths for multiple targets
- **Iterative algorithms**: Parallel PageRank for large graphs

### Memory Considerations
- **Node2Vec walks**: Memory usage = `num_nodes × num_walks × walk_length × sizeof(NodeId)`
- **Embeddings**: Memory usage = `num_nodes × dimension × sizeof(f32)`
- **Betweenness**: O(V³) worst case for dense graphs

### Optimization Strategies
1. **Cache results** when running multiple queries
2. **Batch operations** instead of individual calls
3. **Use parallel algorithms** for CPU-bound tasks
4. **Tune parameters**:
   - PageRank: Lower tolerance for faster convergence
   - Node2Vec: Shorter walks for faster training
   - Parallel: Adjust `rayon` thread pool size

## Example: Social Network Analysis

```rust
use zipgraph_core::{Graph, centrality::*};
use zipgraph_ml::embeddings::Node2VecTrainer;

// Build social network graph
let mut graph = Graph::new();
// ... add users and friendships ...

// Find influencers (high PageRank)
let ranks = pagerank(&graph, 0.85, 100, 1e-6)?;
let mut influencers: Vec<_> = ranks.iter().collect();
influencers.sort_by(|a, b| b.1.partial_cmp(a.1).unwrap());
println!("Top 10 influencers:");
for (node_id, rank) in influencers.iter().take(10) {
    println!("  User {}: rank = {:.6}", node_id, rank);
}

// Find community connectors (high betweenness)
let betweenness = betweenness_centrality(&graph)?;
let mut connectors: Vec<_> = betweenness.iter().collect();
connectors.sort_by(|a, b| b.1.partial_cmp(a.1).unwrap());
println!("\nTop 10 community bridges:");
for (node_id, score) in connectors.iter().take(10) {
    println!("  User {}: betweenness = {:.6}", node_id, score);
}

// Generate user embeddings for recommendations
let trainer = Node2VecTrainer::new(10, 20, 64);
let embeddings = trainer.train(&graph)?;

// Find similar users
let user_id = 42;
let similar_users = embeddings.most_similar(user_id, 5)?;
println!("\nUsers similar to User {}:", user_id);
for (similar_id, score) in similar_users {
    println!("  User {}: similarity = {:.4}", similar_id, score);
}
```

## Testing

All new features include comprehensive tests:

```bash
# Run specific test module
cargo test -p zipgraph-core centrality

# Run with verbose output
cargo test -- --nocapture

# Run parallel tests
cargo test -p zipgraph-core parallel

# Run Node2Vec tests
cargo test -p zipgraph-ml node2vec
```

## Documentation

Generate and view full API documentation:

```bash
cargo doc --no-deps --open
```

---

For more examples, see the `examples/` directory in the repository.
